Jack Wilburn
Homework 3

Q1a: Doing a signature with RSA alone on a long message would be too slow (presumably using cipher block chaining). Suppose we could do division quickly. Would it be reasonable to compute an RSA signature on a long message by first finding what the message equals, mod n, and signing that?

It is unreasonable to do the division described above to shorten the time it takes to compute an RSA signature. You'd be much more likely to get a collision between messages in this system, where m would collide with m mod n, and any other message that maps to m mod n.

Q1b: Consider  a  simple  authentication  protocol  using  hash  functions  where Bob  sends  a  random  number  rA  to  Alice  and  Alice  responds  with  SHA512(KAB AND rA). Could Trudy, impersonating Bob, send Alice a sequence of challenges rA that will reveal KAB?

Yes, I think it's possible with just one challenge. If you make rA the same length as the key, and comprised of all 1s, then the AND operation will return just the key. Bitwise AND on a binary number of all 1s returns what it was ANDed with.

Q1c: Suppose Alice sends a message to Bob by representing each alphabetic 
character  as  an  integer  between  0  and  25  (A  ->  0,  B  ->  1,...,  Z->  25)  and  then encrypting  each  number  separately  using  RSA  with  a  large  e  and  a  large  n. Describe an efficient attack against this encryption method. 

Since each character has a 1 in 26 chance of occurring, it would be possible to brute force the possible combinations of letters. The encrypted message would repeat very frequently so you'd be able to create a mapping from a brute forced block to a letter, which would speed up decryption greatly.

Q1d: Show that (xc mod n)d mod n = xcd mod n

I'm not sure how I'd show this. It comes from the fact that the exponentiation is associative so can be applied in any order under modulo arithmetic.

Q2a: Encrypting the Diffie-Hellman value with the other side’s RSA public 
key prevents the person-in-the-middle attack. Why is this the case, given that the attacker can encrypt whatever it wants with the other side’s public key? 

Only the other side can decrypt it with their private key. This means no one else can sit in the middle, since they don't know the other side's private key.

Q2b: Suppose  the  public  Diffie  Hellman  key  of  Bob  is  TB  =  g^SB  mod  p. How  does  Alice  send  a  secret  message  m  using  the  Diffie  Hellman  scheme  to Bob? [Assume that (g, p) are known to Alice and Bob ahead of time.]

Alice sends the message m using TAB = (g^SB  mod  p)^SA mod p as the encryption key.

Q2c: Let there be n people in a group. Each person in the group wishes to establish a secret with every other person in the group. Let us assume that each person can send broadcast messages to reach all the other members of the group. Show  an  efficient  Diffie-Hellman  exchange  that  allows  each  member  of  the group  to  establish  a  secret  with  every  other  member  of  the  group.  How  many broadcast messages does your scheme use? 

Each person with keys (Pa, Pb, ..., Pn) in the group should take turns sending their key after exponentiating with g. That is, person a sends g^(Pa) mod p, person b sends g^(Pb) mod p, etc. Each other person is listening and combining the broadcasted keys together to build up the group key. The group key will eventually look like g^(Pa * Pb * ... * Pn) mod p. This strategy would only require n public key broadcasts, one for each person in the group.

Q3a: Design  your  own  zero  knowledge  proof  system  for  interactive authentication using the ideas presented in Section 6.8 of the textbook. You must present arguments to show that your scheme is secure. (You can find a long list of NP-complete problems in the book by Michael Garey and David Johnson.) 

1) Alice creates a large graph that has a Hamiltonian cycle. No one else can compute whether or not it has a cycle in a reasonable amount of time.
2) Alice creates a random permutation of G with a random addition of edges and shares that graph with Bob.
3) Bob asks for the list of vertices that make the cycle.
4) Alice gives those vertices and Bob verifies that it makes a cycle.

For any brand new permutation of the graph that Alice generated, there's no way that an attacker could generate a Hamiltonian cycle before Alice, and thus the algorithm verifies Alice's identity, without revealing her secret key. Each time a graph is used, it must be discarded, and another graph must be made. Since the original graph is generated (and could have been generated by anyone), there's no knowledge that is transferred. 

Q3b: Transform  your  scheme  into  a  zero  knowledge  signature  scheme  and also show that your signature scheme is secure

Under my scheme, Alice's secret is the Hamiltonion cycle that she generated. She transmits a newly derived graph from her signature and is able to answer questions about which nodes are in the cycle. For any edge, she's able to answer if it's in it or not, which no other person would be able to do. Thus this scheme is secure.

Q4: Submitted via handin

Q5a: Briefly describe the properties of the wireless channel between a pair of wireless nodes that enable these nodes to extract a symmetric/secret bit sequence? 

The wireless channel must be unable to be predictably blocked. Additionally, the communicators must not be static, since most of the variation comes from hardware imperfections, which are lower entropy.

Q5b: What  is  the  similarity  between  the  secret  key  extraction  presented  in this paper and the Diffie-Hellman cryptosystem? 

This secret key extraction uses information that is broadcast publicly to create a unique key that is hard to brute force, similarly to Diffie-Hellman. An attacker can see all messages in plain text and can monitor the environment until the key is generated, and at such time, the messages become entirely obfuscated and encrypted. 

Q5c: Does  the  method  of  secret  key  extraction  from  the  wireless  channel between Alice and Bob provide perfect forward secrecy? Explain briefly.

In theory it does. Once the secret key is established, it would be very difficult to crack the key. The randomness of the wireless channel between the the two devices would be hard to predict and the keys will be computationally infeasible to calculate. The only way it might not be is if the person in the middle is not able to interfere.

Q5d: Why  is  it  not  useful  to  extract  secret  bits  from  wireless  channels  in static  environments?  How  can  an  adversary  make  Alice  and  Bob  agree  upon  a predictable key pattern?

In a static environment, an adversary can manipulate the wireless channel between Alice and Bob in such a way that they can control the key generation. Being able to control the generation, means that they can influence the key that is created, meaning that it would be easier for them to extract the value of the key and decrypt the messages. A way this might be achieved is by breaking the line-of-sight between the 2 devices repeatedly.

