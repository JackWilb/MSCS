
% --------------------------------------------------------------
% This is all preamble stuff that you don't have to worry about.
% Head down to where it says "Start here"
% --------------------------------------------------------------

\documentclass[11pt]{article}

\usepackage{bera}
%\renewcommand{\familydefault}{\rmfamily}

\usepackage{graphicx,url}
\usepackage{proof}
\usepackage{framed}
\usepackage{etaremune}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage{paralist}
\thispagestyle{empty}

% 1. To get version suitable for students to populate,
%    remove the contents of the \ignoreSoln{..body..}
%
% 2. To get a version suitable for generating PDF 
%    without solutions, remove the #1 below
%
% 3. To generate solutions, keep the #1 below
%
% 4. Assigned grader fills \ignoreSoln{..body..}
%    and also provides his/her feedback to student
%    and policy followed for point deduction
%    So design policy before grading begins.

\newcommand{\ignoreSoln}[1]{#1}   
%\newcommand{\ignoreModel}[1]{#1} 


\newcommand{\bigset}[2]{\big\{\;#1\;:\;#2\;\big\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Np}{\mathbb{N^{+}}}

\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\DeclareMathSizes{14}{14}{14}{14}

\begin{document}

% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------

%\renewcommand{\qedsymbol}{\filledbox}
\newlength{\minpagw}
\settowidth{\minpagw}{\hspace{40em}}

\begin{center}
\begin{large}
  CS 6110, Spring 2022, Assignment 3  \\
  Given 2/3/22 -- Due 2/10/22 by 11:59 pm via your Github 
  \ \\
%  \ \\  
    {  {\Large\bf NAME: Jack Wilburn} \hfill {\Large\bf UNID: u0999308}\hspace{4cm} }
          \ \\
\end{large}

\end{center}

\noindent{\bf CHANGES:\/} {\bf Please look for lines beginning with underlined words when they are made.}
         {\tiny none yet.}

         \noindent {\bf Answering, Submission:\/}
         Have these on your private Github:
         a folder Asg3/ containing your submission, which in detail comprises:
         \begin{compactitem}
         \item A clear README.md describing your files.
         \item Files that you ran + documentation (can be integrated in one place).
         \item A high level summary of your cool findings + insights + learning -- briefly reported in
           a nicely bulletted fashion in your PDF submission.
         \end{compactitem}

         \noindent {\bf Start Early, Ask Often!}
Orientation videos and further help will be available (drop a note anytime
on Piazza for help). {\em I encourage students constructing answers jointly!}

\begin{enumerate}
  
%- 1 ----------------------------------------------------------------
\item (8 points)
  This is on practicing the use of Murphi.
  At the end of this assignment, I include the N-Process Peterson protocol
  for mutual exclusion, described in
  \url{https://en.wikipedia.org/wiki/Peterson%27s_algorithm}.
  %
  (This comes from the Murphi distribution; pasting it here for your
  convenience.)
  %
  Your task is to set-up Murphi or Rumur, run this protocol for 3 processes, and
  see if you can get an estimate of the state-space of the protocol.
  %
  I recommend that Murphi be obtained from
  \url{http://mclab.di.uniroma1.it/site/index.php/software/18-cmurphi} (latest version)
  or obtain Rumur from
  \url{https://github.com/Smattr/rumur}.
  %
  Your luck in building these may vary---let's have a dialog next week on this.
  %
  We will offer help if you get stuck, so please raise it on Piazza.
  %
  Once you understand the coding of Murphi, kindly develop a bulletted summary of its
  constructs.
  %
  I'll be adding more Murphi documentation in the interim.
  %
  Here are some tips:
  %
  \begin{compactitem}
  \item looks like we just need to run with the default -v
    instead of -s which seems to be the difference between verification and continuous simulation.
    [ Correct. also -vdfs is for DFS verification. ]
    
  \item Please try for N=3 and N=5 (constants at the top). I don't mind if $>5$ is not tried (although it ought
    to finish).

  \item Please also try with symmetry reduction (the -sym flag ; it also takes a number like 1 or 2).
    With that, it will take more time per printout (per batch of rules) but will be very memory-efficient. 

  \item If it says "out of memory", you can give e.g. another flag "-m32" and then "-m64" etc.
    That is the megabytes allocated.

  \item Finally, the printouts take time away from the model-checker.
    Making its printing rate go down can make it somewhat faster.
    (Already the printing rate is not too high, but every bit helps.)

  \item At the bottom of the file there is a recording of former runs they finished using this tool
    (way back in 1998 or so). That is the kind of result I'm looking for.
  \end{compactitem}



\begin{minipage}{\minpagw}
  \fbox{%
    \parbox{\linewidth}{%
      I installed rumur and checked the model with it. I didn't need -v or -s, it seems it has quite a different interface to check the murphi code.
      
      N = 3 mapped to 172 states. N = 5 mapped to 6770 states. N = 7 mapped to 163298 states. The state space increases very quickly, probably exponentially or worse.
      
      Using rumur's exhaustive symmetry reduction was much slower. For N = 6 (7 took too long), it took ~31 seconds with symmetry reduction and less than 1 second without.
      
      Print outs weren't really an issue with rumur. It would only print every 10,000 states, so it was a small fractin of the total time it took to check the models.
      
      I've attached some terminal output below the answer box.
    }%
  }%
\end{minipage}

\begin{tiny}
    \begin{verbatim}
        [jwilburn@thinkbook homework3]$ rumur q1-peterson.m --output q1-peterson.c --symmetry-reduction exhaustive
cc -std=c11 -O3 q1-peterson.c -lpthread -mcx16
./a.out
Memory usage:

        * The size of each state is 75 bits (rounded up to 10 bytes).
        * The size of the hash table is 32768 slots.

Progress Report:

         thread 10: 10000 states explored in 9s, with 3288 rules fired and 55 states in the queue.
         thread 7: 20000 states explored in 17s, with 6988 rules fired and 80 states in the queue.
         thread 5: 30000 states explored in 26s, with 10938 rules fired and 68 states in the queue.

==========================================================================

Status:

        No error found.

State Space Explored:

        35159 states, 210954 rules fired in 31s.
    \end{verbatim}
\end{tiny}
\clearpage
%- 2 ----------------------------------------------------------------
\item (2 points) Read about the Photoshop bug (a light read) from the paper photoshop-bug.pdf in the repo.
  Summarize your thought in a few lines. This is to tell you how real-world bugs often fester, and
  interface-differences may trip up people.
  
\begin{minipage}{\minpagw}
  \fbox{%
    \parbox{\linewidth}{%
      I learned Amdahl's law from this paper. That when parallelizing, you will always be limited by the section of the program that cannot be parallelized. That is, if a one hour section of code must run serially, then the fastest your program will ever run is in one hour.
      
      The bug was in the asynchronous I/O code. On macs, the call to set the file position was one instruction, whereas on windows it was 2, and it wasn't set to atomic. 
      
      There's lots of interesting talk about NUMA, and other large processor features that we see now in 2022. The way that they're talking about them seems a bit antiquated since we now have the processors, and I wonder how their opinions on dealing with "a cluster in a box" has changed.
      
      I wonder if the new M1 architecture has helped with the memory bandwidth issues they were seeing on multicore architectures.
      
      Also, the change to more heterogeneous cores inside a processor, such as neural processing units, dedicated accelerators and such are discussed, but not with the scale and ubiquity that we have them today, in our phones, etc.
      
      It's cool to see how relevant all these topics are after 12 years.
    }%
  }%
\end{minipage}

\clearpage
  
%- 3 ----------------------------------------------------------------  
\item (90 points)
  The main part of this assignment is to debug a locking protocol given in
  Promela. The protocol written by an expert (my former PhD student) is included
  with comments in locking-prot.tex and locking-prot.pdf.
  %
  Set-up:
  \begin{enumerate}
  \item This protocol, as implemented, has a bug
  \item Like almost all bugs, this occurs exactly on one line
  \item Like almost all bugs, the fix is also a small change on the line
  \end{enumerate}
  Your task:
  \begin{enumerate}
  \item Discover this bug by a ``{\tt spin -a}'' run
  \item You can discover the bug in a depth of 90 or less by running  ``{\tt
    pan -a -m90}'' 
  \item You can simply look at the last state printed by
    ``{\tt spin  -s -r -t locking-buggy.pml}'' and spot the bug
  \item Fix the bug and rerun. {\em The fix consists of making one of the guard conditions stronger.}
  \item Can a node decide to toss  requests to a random node rather than along the PO chain?
    (It might do this to avoid network congestion.) Justify this, and implement + verify in
    the fixed version of your protocol (make some nodes nondeterministically toss the
    request to a random PO than its actual PO).
  \item Explain your insights!
  \end{enumerate}  


\begin{minipage}{\minpagw}
  \fbox{%
    \parbox{\linewidth}{%
      The bug seemed to be in the handle atomic wait section. It was waiting for a request, but not making sure its own request queue was empty. If it had requests, it was about to be set to the owner of the lock so it should wait, claim ownership, and add incoming requests to its queue. Since it wasn't doing that, it was getting stuck in a transient state. See q3-locking-prot-fixed for this solution.
      
      In theory you should be able to pass the request to a random node and have it get to the desired location, because every node should have a complete path to a probable owner. Given that sometimes you'd hit the right node by accident and sometimes you'd hit a node at the end of the path, the latency could be much larger. I think the code I'm submitting shows this. It hits the max depth with 10s of millions of states tested without crashing and failing the acceptance checks.
    }%
  }%
\end{minipage}  
\end{enumerate}

\begin{tiny}
\begin{verbatim}
--------------------------------------------------------------------------
-- Copyright (C) 1992 by the Board of Trustees of 			  
-- Leland Stanford Junior University.					  
--									  
-- This description is provided to serve as an example of the use	  
-- of the Murphi description language and verifier, and as a benchmark	  
-- example for other verification efforts.				  
--									  
-- License to use, copy, modify, sell and/or distribute this description  
-- and its documentation any purpose is hereby granted without royalty,   
-- subject to the following terms and conditions, provided		  
--									  
-- 1.  The above copyright notice and this permission notice must	  
-- appear in all copies of this description.				  
-- 									  
-- 2.  The Murphi group at Stanford University must be acknowledged	  
-- in any publication describing work that makes use of this example. 	  
-- 									  
-- Nobody vouches for the accuracy or usefulness of this description	  
-- for any purpose.							  
--------------------------------------------------------------------------

--------------------------------------------------------------------------
--
--                                                                        
-- File:        muxn.m                                                    
--                                                                        
-- Content:     Peterson's algorithm (mutual exclusion for n-processes)   
--                                                                        
-- Summary of result:                                                     
--          1)  No bug is discovered 					  
--          2)  Details of result can be found at the end of this file.   
--                                                                        
-- References: 						       	       	  
-- Peterson, G.L.,  Myths about the mutual exclusion problem,             
-- Information processing letters, Vol 12, No 3, 1981.                    
--                                                                        
-- Date created:         28 Oct 92                                        
-- Last Modified:        17 Feb 93                                        
--                                                                        
--------------------------------------------------------------------------

Const
  N: 7;	

Type
  --  The scalarset is used for symmetry, which is implemented in Murphi 1.5
  --  and not upgraded to Murphi 2.0 yet
  pid: scalarset (N);
  -- pid: 1..N;
  priority: 0..N;
  label_t: Enum{L0, -- : non critical section; j := 1; while j<n do
		L1,  -- : Beginwhile Q[i] := j
		L2,  -- : turn[j] := i
		L3,  -- : wait until (forall k != i, Q[k] < j) or turn[j] != i ; j++; Endwhile
		L4   -- : critical section; Q[i] := 0
 		};
Var
  P: Array [ pid ] Of label_t;
  Q: Array [ pid ] Of priority;
  turn: Array [ priority ] Of pid;
  localj: Array [ pid ] Of priority;

Ruleset i: pid  Do

  Rule "execute inc j and while"
    P[i] = L0  ==>
  Begin
    localj[i] := 1;
    P[i] := L1; 
  End;

  Rule "execute assign Qi j"
    P[i] = L1  ==>
  Begin
    Q[i] := localj[i];
    P[i] := L2; 
  End;

  Rule "execute assign TURNj i"
    P[i] = L2  ==>
  Begin
    turn[localj[i]]  := i;
    P[i] := L3; 
  End;

  Rule "execute wait until"
    P[i] = L3  ==>
  Begin
    If ( Forall k: pid Do
           ( k!=i ) -> ( Q[k]<localj[i] )
         End --forall
       | ( turn[localj[i]] != i ) )
    Then
      localj[i] := localj[i] + 1;
      If ( localj[i]<N )
      Then
        P[i] := L1; 
      Else
        P[i] := L4; 
      End; --If 
    End; --If
  End;

  Rule "execute critical and assign Qi 0"
    P[i] = L4  ==>
  Begin
    Q[i] := 1;
    P[i] := L0;
  End; 

End; --Ruleset

Startstate
Begin
  For i:pid Do
    P[i] := L0;
    Q[i] := 0;
  End; --For

  For i: priority Do
    Undefine turn[i];
  End; --For

  Clear localj;
End;  

Invariant
  ! Exists i1: pid Do
    Exists i2: pid Do
      ( i1 != i2
      & P[i1] = L4 -- critical
      & P[i2] = L4 -- critical
      )
    End  --Exists
    End; --Exists
 
/******************

Summary of Result (using release 2.3):

1) 3 processes

   breath-first search
   29 bits (4 bytes) per state
   771 states with a max of about 54 states in queue
   2313 rules fired
   0.73s in sun sparc 2 station

2) 5 processes

   breath-first search
   63 bits (8 bytes) per state
   576,551 states with a max of about 22,000 states in queue
   2,882,755 rules fired
   1201.66s in sun sparc 2 station

2.73S

* 3 processes (sparc  2 station)
	* The size of each state is 35 bits (rounded up to 5 bytes).

	BFS -nosym
	882 states, 2646 rules fired in 0.73s.

	BFS -sym1
	172 states, 516 rules fired in 0.36s.

* 5 processes (sparc 2 station)
	* The size of each state is 63 bits (rounded up to 8 bytes).

	BFS -sym1
	6770 states, 33850 rules fired in 22.55s.
	249 states max in the queue.

	BFS -nosym
	628868 states, 3144340 rules fired in 758.92s.
	25458 states max in the queue.

gamma2.9S on theforce.stanford.edu 

  	5 proc
	-O4 compile 119.7s 2.7Mbytes
	    (24 bytes per states)
	-sym2,3,4  6770 states, 33850 rules 14.35s

	6 proc
	-O4 compile 120.2s 2.7Mbytes
	    (28 bytes per states)
        -sym2,3,4  35,159 states, 210954 rules 117.45s 

Release 2.9S (Sparc 20, cabbage.stanford.edu)

   7 processes
         * The size of each state is 232 bits (rounded up to 32 bytes).
      -b * The size of each state is 101 bits (rounded up to 16 bytes).

         163298 states, 1143086 rules fired in 341.93s.
      -b 163298 states, 1143086 rules fired in 378.04s.
      -c 163298 states, 1143086 rules fired in 292.42s.

******************/
  \end{verbatim}
\end{tiny}
  
\end{document}
%- end ----------------------------------------------------------------  
